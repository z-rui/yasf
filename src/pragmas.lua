#!/usr/bin/env lua

local ipairs, print = ipairs, print

local pragmas = {
  {'auto_vacuum', '%o|none|full|incremental|'},
  {'automatic_index', '%b'},
  {'busy_timeout', '%i'},
  {'cache_size', '%i'},
  {'cache_spill', '%b'},
  {'checkpoint_fullfsync', '%b'},
  {'defer_foreign_keys', '%b'},
  {'encoding', '%l', {'UTF-8', 'UTF-16', 'UTF-16le', 'UTF-16be'}},
  {'foreign_keys', '%b'},
  {'fullfsync', '%b'},
  {'ignore_check_constraints', '%b'},
  {'journal_mode', '%l', {'delete', 'truncate', 'persist', 'memory', 'wal', 'off'}},
  {'journal_size_limit', '%i'},
  {'legacy_file_format', '%b'},
  {'locking_mode', '%o', {'normal', 'exclusive'}},
  {'max_page_count', '%i'},
  {'page_size', '%i'},
  {'recursive_triggers', '%b'},
  {'secure_delete', '%b'},
  {'soft_heap_limit', '%i'},
  {'synchronous', '%o|off|normal|full|'},
  {'temp_store', '%o|default|file|memory|'},
  {'threads', '%i'},
  {'user_version', '%i'},
  {'wal_autocheckpoint', '%i'},
}


--- below is code for code generation

print [[
/* Generated by pragmas.lua; DO NOT EDIT. */

#include <string.h>
]]

-- struct def
print(([[
struct pragmas {
  int args[%d];
};]]):format(#pragmas))

-- names
print [[
static
const char * const pragma_names[] = {]]
for _, v in ipairs(pragmas) do
  print (('  "%s",'):format(v[1]))
end
print [[
  0
};
]]

-- get_pragmas
print [[
static
void get_pragmas(sqlite3 *db, struct pragmas *p)
{
  int i, rc;

  for (i = 0; pragma_names[i]; i++) {
    sqlite3_stmt *stmt;
    const char *pn = pragma_names[i];
    char *zSql;

    zSql = sqlite3_mprintf("pragma %s;", pn);
    rc = sqlite3_prepare_v2(db, zSql, -1, &stmt, 0);
    if (report(rc, 0))
      goto free;
    rc = sqlite3_step(stmt);
    if (rc == SQLITE_ROW) {
      int type;

      type = sqlite3_column_type(stmt, 0);
      if (type == SQLITE_INTEGER) {
        p->args[i] = sqlite3_column_int(stmt, 0);
      } else if (type == SQLITE_TEXT) {
        const char *value;

        value = (const char *) sqlite3_column_text(stmt, 0);
]]
for i, v in ipairs(pragmas) do
  if v[3] then
    print(([[
        if (i == %d) {  /* %s */]]):format(i-1, v[1]))
    for j, option in ipairs(v[3]) do
      print(([[
          if (strcmp(value, "%s") == 0)
            p->args[i] = %d;
          else]]):format(option, j-1))
    end
    print [[
            assert(0 && "unknown option");
        } else]]
  end
end
print [[
        {
          assert(0 && "unknown pragma name");
        }
      } else {
        assert(0 && "unknown type of pragma result");
      }
    } else {
      report(rc, 0);
    }
    sqlite3_finalize(stmt);
free:
    sqlite3_free(zSql);
  }
}
]]

-- set_pragmas
print [[
static
void set_pragmas(sqlite3 *db, const struct pragmas *p, const struct pragmas *oldp)
{
  int i, rc;

  for (i = 0; pragma_names[i]; i++) {
    char *zSql;

    if (p->args[i] == oldp->args[i])  /* no change */
      continue;
]]
for i, v in ipairs(pragmas) do
  if v[3] then
    print(([[
    if (i == %d) {  /* %s */
      static const char *options[] = { "%s" };
]]):format(i-1, v[1], table.concat(v[3], '", "')))
    print [=[
      assert(0 <= p->args[i] && p->args[i] < (sizeof options / sizeof options[0]));
      zSql = sqlite3_mprintf("pragma %s = \"%s\";", pragma_names[i], options[p->args[i]]);
    } else]=]
  end
end
print [[
    {
      zSql = sqlite3_mprintf("pragma %s = %d;", pragma_names[i], p->args[i]);
    }
    rc = sqlite3_exec(db, zSql, 0, 0, 0);
    report(rc, 0);
    sqlite3_free(zSql);
  }
}
]]

-- cb_edit_pragmas
print [[
static
int cb_pragmas_param(Ihandle *ih, int idx, void *data)
{
  if (idx == IUP_GETPARAM_BUTTON3) {
    IupHelp("https://www.sqlite.org/pragma.html");
  }
  return 1;
}

int cb_edit_pragmas(Ihandle *ih)
{
  int rc;
  static struct pragmas p, oldp;

  get_pragmas(glst->db, &p);
  oldp = p;
  rc = IupGetParam("Edit Pragmas", cb_pragmas_param, 0,
    "%u[,,Help]\n"]]
for _, v in ipairs(pragmas) do
  if v[3] then
    print(([[
    "%s: %s|%s|\n"]]):format(v[1], v[2], table.concat(v[3], '|')))
  else
    print(([[
    "%s: %s\n"]]):format(v[1], v[2]))
  end
end
for i, v in ipairs(pragmas) do
  print(([=[
    , &p.args[%d]]=]):format(i-1))
end
print [[
  , 0);
  if (rc) {
    set_pragmas(glst->db, &p, &oldp);
  }
  return IUP_DEFAULT;
}
]]

-- vim: ts=2:sw=2:et
